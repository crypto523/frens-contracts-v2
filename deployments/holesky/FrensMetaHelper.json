{
  "address": "0xA8cE2f4279Dc47325EF8CD0b3fB1d6F50DC7bd96",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IFrensStorage",
          "name": "frensStorage_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "getDepositStringForId",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "getEns",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        },
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountInWei",
          "type": "uint256"
        }
      ],
      "name": "getEthDecimalString",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "getPoolString",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x5e428915f6b07c4279940e836fd9339d870d337020ad4cdbe3182b93bda44749",
  "receipt": {
    "to": null,
    "from": "0x6C55105954b7fd0c4Bf3df00dFD739fA71e2fD20",
    "contractAddress": "0xA8cE2f4279Dc47325EF8CD0b3fB1d6F50DC7bd96",
    "transactionIndex": 3,
    "gasUsed": "700154",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x29a670be34f2c52ad4bdeb45efad2c0b1a67cf03868aa54ca46fa95e843d3abb",
    "transactionHash": "0x5e428915f6b07c4279940e836fd9339d870d337020ad4cdbe3182b93bda44749",
    "logs": [],
    "blockNumber": 581357,
    "cumulativeGasUsed": "791418",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x5ABbB94D1305E1cD73A1f976b54b548fBAE6f401"
  ],
  "solcInputHash": "0094c53acd56707fe5afb6d6a907a1e6",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IFrensStorage\",\"name\":\"frensStorage_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getDepositStringForId\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getEns\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"getEthDecimalString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getPoolString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getDepositStringForId(uint256)\":{\"returns\":{\"_0\":\"the deposit for an NFT ID in string format\"}},\"getEns(address)\":{\"returns\":{\"_0\":\"does the address have an ENS set?\",\"_1\":\"string of the ENS for the address\"}},\"getEthDecimalString(uint256)\":{\"returns\":{\"_0\":\"an amount in wei formated as Eth with 3 decimal places, as a string\"}},\"getPoolString(uint256)\":{\"returns\":{\"_0\":\"string version of pool address for an NFT ID\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/FrensMetaHelper.sol\":\"FrensMetaHelper\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\",\"keccak256\":\"0xf0f689f041c9970ece22ba42dc66cacf2aee78699e1eab26658becb738322356\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xab28a56179c1db258c9bf5235b382698cb650debecb51b23d12be9e241374b68\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd1556954440b31c97a142c6ba07d5cade45f96fafd52091d33a14ebe365aecbf\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xa4d1d62251f8574deb032a35fc948386a9b4de74b812d4f545a1ac120486b48a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"contracts/FrensMetaHelper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n///@title Frens Meta Helper\\n///@author 0xWildhare and Frens Team\\n///@dev support functions for FrensArt and FrensPoolShareTokenURI\\n\\nimport \\\"./interfaces/IFrensMetaHelper.sol\\\";\\nimport \\\"./interfaces/IFrensPoolShare.sol\\\";\\nimport \\\"./interfaces/IENS.sol\\\";\\nimport \\\"./interfaces/IReverseResolver.sol\\\";\\nimport \\\"./interfaces/IStakingPool.sol\\\";\\nimport \\\"./interfaces/IFrensStorage.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\ncontract FrensMetaHelper is IFrensMetaHelper {\\n    using Strings for uint256;\\n    IFrensPoolShare frensPoolShare;\\n    IFrensStorage frensStorage;\\n\\n    constructor(IFrensStorage frensStorage_) {\\n        frensStorage = frensStorage_;\\n        frensPoolShare = IFrensPoolShare(frensStorage.getAddress(keccak256(abi.encodePacked(\\\"contract.address\\\", \\\"FrensPoolShare\\\"))));\\n    }\\n\\n    ///@return the deposit for an NFT ID in string format\\n    function getDepositStringForId(\\n        uint id\\n    ) external view returns (string memory) {\\n        IStakingPool stakingPool = IStakingPool(frensPoolShare.getPoolById(id));\\n        return getEthDecimalString(stakingPool.depositForId(id));\\n    }\\n\\n    ///@return an amount in wei formated as Eth with 3 decimal places, as a string\\n    function getEthDecimalString(\\n        uint amountInWei\\n    ) public pure returns (string memory) {\\n        string memory leftOfDecimal = (amountInWei / 1 ether).toString();\\n        uint rightOfDecimal = (amountInWei % 1 ether) / 10 ** 15;\\n        string memory rod = rightOfDecimal.toString();\\n        //if(rightOfDecimal < 1000) rod = string.concat(\\\"0\\\", rod);\\n        if (rightOfDecimal < 100) rod = string.concat(\\\"0\\\", rod);\\n        if (rightOfDecimal < 10) rod = string.concat(\\\"0\\\", rod);\\n        return string.concat(leftOfDecimal, \\\".\\\", rod);\\n    }\\n\\n    ///@return string version of pool address for an NFT ID\\n    function getPoolString(uint id) external view returns (string memory) {\\n        IStakingPool stakingPool = IStakingPool(frensPoolShare.getPoolById(id));\\n        return Strings.toHexString(uint160(address(stakingPool)), 20);\\n    }\\n\\n    ///@return does the address have an ENS set?\\n    ///@return string of the ENS for the address\\n    function getEns(address addr) external view returns (bool, string memory) {\\n        IENS ens = IENS(address(frensStorage.getAddress(keccak256(abi.encodePacked(\\\"external.contract.address\\\", \\\"ENS\\\")))));\\n        bytes32 node = _node(addr);\\n        address revResAddr = ens.resolver(node);\\n        if (revResAddr == address(0)) return (false, \\\"\\\");\\n        IReverseResolver reverseResolver = IReverseResolver(revResAddr);\\n        return (ens.recordExists(node), reverseResolver.name(node));\\n    }\\n\\n    function _node(address addr) internal pure returns (bytes32) {\\n        bytes32 ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\\n        return\\n            keccak256(\\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\\n            );\\n    }\\n\\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\\n        addr;\\n        ret; // Stop warning us about unused variables\\n        assembly {\\n            let\\n                lookup\\n            := 0x3031323334353637383961626364656600000000000000000000000000000000\\n            for {\\n                let i := 40\\n            } gt(i, 0) {\\n\\n            } {\\n                i := sub(i, 1)\\n                mstore8(i, byte(and(addr, 0xf), lookup))\\n                addr := div(addr, 0x10)\\n                i := sub(i, 1)\\n                mstore8(i, byte(and(addr, 0xf), lookup))\\n                addr := div(addr, 0x10)\\n            }\\n            ret := keccak256(0, 40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x446caa0f7ba537a12580a573e25e4f1451ee84e28ac5b690896325ae9a550b05\",\"license\":\"MIT\"},\"contracts/interfaces/IENS.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface IENS {\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\\n    function setResolver(bytes32 node, address resolver) external;\\n    function setOwner(bytes32 node, address owner) external;\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n    function setApprovalForAll(address operator, bool approved) external;\\n    function owner(bytes32 node) external view returns (address);\\n    function resolver(bytes32 node) external view returns (address);\\n    function ttl(bytes32 node) external view returns (uint64);\\n    function recordExists(bytes32 node) external view returns (bool);\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\",\"keccak256\":\"0x71ec8963cc6af99db89417e259f4987b2503e31585db6450e7140e192d868e32\",\"license\":\"MIT\"},\"contracts/interfaces/IFrensArt.sol\":{\"content\":\"pragma solidity 0.8.20;\\n//SPDX-License-Identifier: MIT\\n\\ninterface IFrensArt {\\n  function renderTokenById(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x9ca4f7eb7011a8f1ed7a6d9a0f88ab68b29d49b63aa8864a694b63d5551a0bad\",\"license\":\"MIT\"},\"contracts/interfaces/IFrensMetaHelper.sol\":{\"content\":\"pragma solidity 0.8.20;\\n//SPDX-License-Identifier: MIT\\n\\ninterface IFrensMetaHelper {\\n\\n  //function getColor(address a) external pure returns(string memory);\\n\\n  function getEthDecimalString(uint amountInWei) external pure returns(string memory);\\n\\n  // function getOperatorsForPool(address poolAddress) external view returns (uint32[] memory, string memory);\\n\\n  function getPoolString(uint id) external view returns (string memory);\\n\\n  function getEns(address addr) external view returns(bool, string memory);\\n\\n  function getDepositStringForId(uint id) external view returns(string memory);\\n}\\n\",\"keccak256\":\"0xc08609d3c44bdaf6d77150129ed72337dfaee1a560e305bd2f435bb8ac0d1f46\",\"license\":\"MIT\"},\"contracts/interfaces/IFrensPoolShare.sol\":{\"content\":\"pragma solidity 0.8.20;\\n//SPDX-License-Identifier: MIT\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC721Enumerable.sol\\\";\\n\\n\\ninterface IFrensPoolShare is IERC721Enumerable{\\n  \\n  function poolByIds(uint _id) external view returns(address);\\n\\n  function mint(address userAddress) external;\\n\\n  function burn(uint tokenId) external;\\n\\n  function exists(uint _id) external view returns(bool);\\n\\n  function getPoolById(uint _id) external view returns(address);\\n\\n  function tokenURI(uint256 id) external view returns (string memory);\\n\\n  function renderTokenById(uint256 id) external view returns (string memory);\\n\\n}\\n\",\"keccak256\":\"0xef1985c0b95767f7b96d1f21aed9e48142c021d25d574f0615323ec2b83ad996\",\"license\":\"MIT\"},\"contracts/interfaces/IFrensStorage.sol\":{\"content\":\"pragma solidity 0.8.20;\\n\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n//modified from IRocketStorage on 03/12/2022 by 0xWildhare\\n\\ninterface IFrensStorage {\\n\\n   \\n    // Guardian\\n    function getGuardian() external view returns(address);\\n    function setGuardian(address _newAddress) external;\\n    function confirmGuardian() external;\\n    function burnKeys() external;\\n\\n    // Getters\\n    function getAddress(bytes32 _key) external view returns (address);\\n    function getUint(bytes32 _key) external view returns (uint);\\n    function getBool(bytes32 _key) external view returns (bool);   \\n\\n    // Setters\\n    function setAddress(bytes32 _key, address _value) external;\\n    function setUint(bytes32 _key, uint _value) external;\\n    function setBool(bytes32 _key, bool _value) external;    \\n\\n    // Deleters\\n    function deleteAddress(bytes32 _key) external;\\n    function deleteUint(bytes32 _key) external;\\n    function deleteBool(bytes32 _key) external;    \\n\\n    // Arithmetic \\n    function addUint(bytes32 _key, uint256 _amount) external;\\n    function subUint(bytes32 _key, uint256 _amount) external;\\n    \\n}\\n\",\"keccak256\":\"0xfd293708621d8eb26c25db108d90583d36ab7f4a7f1f71a75e0b6f54c9a0a451\",\"license\":\"GPL-3.0-only\"},\"contracts/interfaces/IReverseResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface IReverseResolver{\\n\\n    function name(bytes32 node) external view returns(string memory);\\n\\n}\",\"keccak256\":\"0xc4849e951336ce62ba55f6b4a6158a8c1bc8716e41b83a4afa98b23c1d97442c\",\"license\":\"MIT\"},\"contracts/interfaces/IStakingPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"./IFrensArt.sol\\\";\\n\\ninterface IStakingPool {\\n\\n    function pubKey() external view returns(bytes memory);\\n\\n    function depositForId(uint _id) external view returns (uint);\\n\\n    function totalDeposits() external view returns(uint);\\n\\n    function transferLocked() external view returns(bool);\\n\\n    function locked(uint id) external view returns(bool);\\n\\n    function artForPool() external view returns (IFrensArt);\\n\\n    function owner() external view returns (address);\\n\\n    function depositToPool() external payable;\\n\\n    function addToDeposit(uint _id) external payable;\\n\\n    function withdraw(uint _id, uint _amount) external;\\n\\n    function claim(uint id) external;\\n\\n    function getIdsInThisPool() external view returns(uint[] memory);\\n\\n    function getShare(uint _id) external view returns (uint);\\n\\n    function getDistributableShare(uint _id) external view returns (uint);\\n\\n    function rageQuitInfo(uint id) external view returns(uint, uint, bool);\\n\\n    function setPubKey(\\n        bytes calldata pubKey,\\n        bytes calldata withdrawal_credentials,\\n        bytes calldata signature,\\n        bytes32 deposit_data_root\\n    ) external;\\n\\n    function getState() external view returns (string memory);\\n\\n    // function getDepositAmount(uint _id) external view returns(uint);\\n\\n    function stake(\\n        bytes calldata pubkey,\\n        bytes calldata withdrawal_credentials,\\n        bytes calldata signature,\\n        bytes32 deposit_data_root\\n    ) external;\\n\\n    function stake() external;\\n\\n}\\n\",\"keccak256\":\"0xfcce7e4e1de632af6ab1d89918ff97980a3b0e282eab86875e86128c41260574\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040908082523461014d5780610c25803803809161001f8285610151565b833960209283918101031261014d57516001600160a01b0380821692909183900361014d57600180546001600160a01b0319908116851790915584516f636f6e74726163742e6164647265737360801b8382019081526d4672656e73506f6f6c536861726560901b6030830152601e825291949092838701929091906001600160401b038411858510176101395760248484938193828c52885190206321f8a72160e01b835260448901525afa92831561012f575f936100f2575b50505016905f5416175f5551610ab090816101758239f35b813d8311610128575b6101058185610151565b81010312610124575190828216820361012157505f80806100da565b80fd5b5080fd5b503d6100fb565b86513d5f823e3d90fd5b634e487b7160e01b5f52604160045260245ffd5b5f80fd5b601f909101601f19168101906001600160401b038211908210176101395760405256fe60806040526004361015610011575f80fd5b5f3560e01c806392a2e5ac14610054578063de1c7f701461004f578063edd148a21461004a5763ef21184f14610045575f80fd5b6101d3565b6101a6565b610162565b346100e157610062366100e5565b6020608060248160018060a01b0394855f541690630178b36760e31b83526084525afa80156100dc576100ac916100a0915f906100b0575b166106de565b6040519182918261013d565b0390f35b5060203d81116100d5575b806100c86100d0926102eb565b608001610335565b61009a565b503d6100bb565b610362565b5f80fd5b60209060031901126100e15760043590565b5f5b8381106101085750505f910152565b81810151838201526020016100f9565b90602091610131815180928185528580860191016100f7565b601f01601f1916010190565b90602061014e928181520190610118565b90565b6001600160a01b038116036100e157565b346100e15760203660031901126100e15761018760043561018281610151565b6107db565b906100ac60405192839215158352604060208401526040830190610118565b346100e1576100ac6101bf6101ba366100e5565b6103b6565b604051918291602083526020830190610118565b346100e1576101e1366100e5565b5f546101fd906001600160a01b03165b6001600160a01b031690565b604051630178b36760e31b8152600481018390526020918290829060249082905afa9283156100dc576102549383925f916102aa575b506040518080968194632daad61d60e01b8352600483019190602083019252565b03916001600160a01b03165afa80156100dc576100ac926100a0925f9261027d575b50506103b6565b61029c9250803d106102a3575b6102948183610313565b81019061036d565b5f80610276565b503d61028a565b6102ca9150833d85116102d0575b6102c28183610313565b81019061034d565b5f610233565b503d6102b8565b634e487b7160e01b5f52604160045260245ffd5b601f80199101166080016080811067ffffffffffffffff82111761030e57604052565b6102d7565b90601f8019910116810190811067ffffffffffffffff82111761030e57604052565b602090607f1901126100e15760805161014e81610151565b908160209103126100e1575161014e81610151565b6040513d5f823e3d90fd5b908160209103126100e1575190565b906103b460216040518094600360fc1b60208301526103a481518092602086860191016100f7565b8101036001810185520183610313565b565b66038d7ea4c68000670de0b6b3a76400006103d2818404610508565b920604906103df82610508565b9160648110610456575b600a1161043e575b602161014e9160405193816104108693518092602080870191016100f7565b8201601760f91b602082015261042f82518093602087850191016100f7565b01036001810184520182610313565b90602161044d61014e9261037c565b929150506103f1565b91610462600a9161037c565b9290506103e9565b67ffffffffffffffff811161030e57601f01601f191660200190565b604051906020820182811067ffffffffffffffff82111761030e576040525f8252565b604051906060820182811067ffffffffffffffff82111761030e57604052602a8252604082602036910137565b906104e08261046a565b6104ed6040519182610313565b82815280926104fe601f199161046a565b0190602036910137565b805f917a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008082101561063b575b506d04ee2d6d415b85acef81000000008083101561062c575b50662386f26fc100008083101561061d575b506305f5e1008083101561060e575b50612710808310156105ff575b5060648210156105ef575b600a809210156105e5575b60019081602161059e8287016104d6565b95860101905b6105b0575b5050505090565b5f19019083906f181899199a1a9b1b9c1cb0b131b232b360811b8282061a8353049182156105e0579190826105a4565b6105a9565b916001019161058d565b9190606460029104910191610582565b6004919392049101915f610577565b6008919392049101915f61056a565b6010919392049101915f61055b565b6020919392049101915f610549565b60409350810491505f610530565b634e487b7160e01b5f52603260045260245ffd5b90815181101561066e570160200190565b610649565b801561067f575f190190565b634e487b7160e01b5f52601160045260245ffd5b1561069a57565b606460405162461bcd60e51b815260206004820152602060248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152fd5b6106e66104a9565b9081511561066e5760306020830153815160019081101561066e5790607860218401536029915b808311610720575061014e915015610693565b90600f811690601082101561066e5761075d916f181899199a1a9b1b9c1cb0b131b232b360811b901a610753858761065d565b5360041c92610673565b919061070d565b908160209103126100e1575180151581036100e15790565b6020818303126100e15780519067ffffffffffffffff82116100e1570181601f820112156100e15780516107af8161046a565b926107bd6040519485610313565b818452602082840101116100e15761014e91602080850191016100f7565b60015490919061087a906107f7906001600160a01b03166101f1565b9260405160209481868093019061085681610848610839856019907f65787465726e616c2e636f6e74726163742e616464726573730000000000000081520190565b62454e5360e81b815260030190565b03601f198101835282610313565b5190209060405180809681946321f8a72160e01b8352600483019190602083019252565b03915afa9182156100dc575f926109be575b506001600160a01b03918216906108a2906109dd565b604051630178b8bf60e01b8152600481018290529092908581602481865afa9081156100dc575f916109a1575b501691821561099257604051631ef3fca760e31b815260048101829052918590839060249082905afa9182156100dc5761092f955f93610961575b50505f9192604051808097819463691f343160e01b8352600483019190602083019252565b03915afa9283156100dc575f9361094557509190565b61014e91933d8091833e6109598183610313565b81019061077c565b5f9350908161098492903d1061098b575b61097c8183610313565b810190610764565b915f61090a565b503d610972565b50505090505f9061014e610486565b6109b89150863d88116102d0576102c28183610313565b5f6108cf565b6109d6919250843d86116102d0576102c28183610313565b905f61088c565b6028805b610a3f57505060285f2060405160208101917f91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e283526040820152604081526060810181811067ffffffffffffffff82111761030e5760405251902090565b6f181899199a1a9b1b9c1cb0b131b232b360811b91600f9182821684901a5f19820153600119019283928260041c161a825360081c916109e156fea2646970667358221220f52b74fe5b5d7c950519715a76d646defad7d91f779be3702ecc9a907b4ddd4364736f6c63430008140033",
  "deployedBytecode": "0x60806040526004361015610011575f80fd5b5f3560e01c806392a2e5ac14610054578063de1c7f701461004f578063edd148a21461004a5763ef21184f14610045575f80fd5b6101d3565b6101a6565b610162565b346100e157610062366100e5565b6020608060248160018060a01b0394855f541690630178b36760e31b83526084525afa80156100dc576100ac916100a0915f906100b0575b166106de565b6040519182918261013d565b0390f35b5060203d81116100d5575b806100c86100d0926102eb565b608001610335565b61009a565b503d6100bb565b610362565b5f80fd5b60209060031901126100e15760043590565b5f5b8381106101085750505f910152565b81810151838201526020016100f9565b90602091610131815180928185528580860191016100f7565b601f01601f1916010190565b90602061014e928181520190610118565b90565b6001600160a01b038116036100e157565b346100e15760203660031901126100e15761018760043561018281610151565b6107db565b906100ac60405192839215158352604060208401526040830190610118565b346100e1576100ac6101bf6101ba366100e5565b6103b6565b604051918291602083526020830190610118565b346100e1576101e1366100e5565b5f546101fd906001600160a01b03165b6001600160a01b031690565b604051630178b36760e31b8152600481018390526020918290829060249082905afa9283156100dc576102549383925f916102aa575b506040518080968194632daad61d60e01b8352600483019190602083019252565b03916001600160a01b03165afa80156100dc576100ac926100a0925f9261027d575b50506103b6565b61029c9250803d106102a3575b6102948183610313565b81019061036d565b5f80610276565b503d61028a565b6102ca9150833d85116102d0575b6102c28183610313565b81019061034d565b5f610233565b503d6102b8565b634e487b7160e01b5f52604160045260245ffd5b601f80199101166080016080811067ffffffffffffffff82111761030e57604052565b6102d7565b90601f8019910116810190811067ffffffffffffffff82111761030e57604052565b602090607f1901126100e15760805161014e81610151565b908160209103126100e1575161014e81610151565b6040513d5f823e3d90fd5b908160209103126100e1575190565b906103b460216040518094600360fc1b60208301526103a481518092602086860191016100f7565b8101036001810185520183610313565b565b66038d7ea4c68000670de0b6b3a76400006103d2818404610508565b920604906103df82610508565b9160648110610456575b600a1161043e575b602161014e9160405193816104108693518092602080870191016100f7565b8201601760f91b602082015261042f82518093602087850191016100f7565b01036001810184520182610313565b90602161044d61014e9261037c565b929150506103f1565b91610462600a9161037c565b9290506103e9565b67ffffffffffffffff811161030e57601f01601f191660200190565b604051906020820182811067ffffffffffffffff82111761030e576040525f8252565b604051906060820182811067ffffffffffffffff82111761030e57604052602a8252604082602036910137565b906104e08261046a565b6104ed6040519182610313565b82815280926104fe601f199161046a565b0190602036910137565b805f917a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008082101561063b575b506d04ee2d6d415b85acef81000000008083101561062c575b50662386f26fc100008083101561061d575b506305f5e1008083101561060e575b50612710808310156105ff575b5060648210156105ef575b600a809210156105e5575b60019081602161059e8287016104d6565b95860101905b6105b0575b5050505090565b5f19019083906f181899199a1a9b1b9c1cb0b131b232b360811b8282061a8353049182156105e0579190826105a4565b6105a9565b916001019161058d565b9190606460029104910191610582565b6004919392049101915f610577565b6008919392049101915f61056a565b6010919392049101915f61055b565b6020919392049101915f610549565b60409350810491505f610530565b634e487b7160e01b5f52603260045260245ffd5b90815181101561066e570160200190565b610649565b801561067f575f190190565b634e487b7160e01b5f52601160045260245ffd5b1561069a57565b606460405162461bcd60e51b815260206004820152602060248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152fd5b6106e66104a9565b9081511561066e5760306020830153815160019081101561066e5790607860218401536029915b808311610720575061014e915015610693565b90600f811690601082101561066e5761075d916f181899199a1a9b1b9c1cb0b131b232b360811b901a610753858761065d565b5360041c92610673565b919061070d565b908160209103126100e1575180151581036100e15790565b6020818303126100e15780519067ffffffffffffffff82116100e1570181601f820112156100e15780516107af8161046a565b926107bd6040519485610313565b818452602082840101116100e15761014e91602080850191016100f7565b60015490919061087a906107f7906001600160a01b03166101f1565b9260405160209481868093019061085681610848610839856019907f65787465726e616c2e636f6e74726163742e616464726573730000000000000081520190565b62454e5360e81b815260030190565b03601f198101835282610313565b5190209060405180809681946321f8a72160e01b8352600483019190602083019252565b03915afa9182156100dc575f926109be575b506001600160a01b03918216906108a2906109dd565b604051630178b8bf60e01b8152600481018290529092908581602481865afa9081156100dc575f916109a1575b501691821561099257604051631ef3fca760e31b815260048101829052918590839060249082905afa9182156100dc5761092f955f93610961575b50505f9192604051808097819463691f343160e01b8352600483019190602083019252565b03915afa9283156100dc575f9361094557509190565b61014e91933d8091833e6109598183610313565b81019061077c565b5f9350908161098492903d1061098b575b61097c8183610313565b810190610764565b915f61090a565b503d610972565b50505090505f9061014e610486565b6109b89150863d88116102d0576102c28183610313565b5f6108cf565b6109d6919250843d86116102d0576102c28183610313565b905f61088c565b6028805b610a3f57505060285f2060405160208101917f91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e283526040820152604081526060810181811067ffffffffffffffff82111761030e5760405251902090565b6f181899199a1a9b1b9c1cb0b131b232b360811b91600f9182821684901a5f19820153600119019283928260041c161a825360081c916109e156fea2646970667358221220f52b74fe5b5d7c950519715a76d646defad7d91f779be3702ecc9a907b4ddd4364736f6c63430008140033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getDepositStringForId(uint256)": {
        "returns": {
          "_0": "the deposit for an NFT ID in string format"
        }
      },
      "getEns(address)": {
        "returns": {
          "_0": "does the address have an ENS set?",
          "_1": "string of the ENS for the address"
        }
      },
      "getEthDecimalString(uint256)": {
        "returns": {
          "_0": "an amount in wei formated as Eth with 3 decimal places, as a string"
        }
      },
      "getPoolString(uint256)": {
        "returns": {
          "_0": "string version of pool address for an NFT ID"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3715,
        "contract": "contracts/FrensMetaHelper.sol:FrensMetaHelper",
        "label": "frensPoolShare",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(IFrensPoolShare)6526"
      },
      {
        "astId": 3718,
        "contract": "contracts/FrensMetaHelper.sol:FrensMetaHelper",
        "label": "frensStorage",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IFrensStorage)6626"
      }
    ],
    "types": {
      "t_contract(IFrensPoolShare)6526": {
        "encoding": "inplace",
        "label": "contract IFrensPoolShare",
        "numberOfBytes": "20"
      },
      "t_contract(IFrensStorage)6626": {
        "encoding": "inplace",
        "label": "contract IFrensStorage",
        "numberOfBytes": "20"
      }
    }
  }
}